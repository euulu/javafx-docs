= UI Controls

== ChoiceBox

This article demonstrates the `ChoiceBox`.  The `ChoiceBox` control is a list of values from which the user makes a selection.  In this particular implementation, there is an empty value which makes the selection optional.

The following screenshot shows `ChoiceBox` app.  A selection "Furniture" is made and the Save `Button` is pressed.  The Save `Button` call invokes a println() which prints out the object.

image::images/ui-controls/choicebox.png[title="ChoiceBox Printing Out Selection"]

The program puts a `Label`, a `ChoiceBox`, and a `Button` into an HBox.  An action is set on the Save `Button` which prints out the value.

The simplest usage of the `ChoiceBox` is to fill it with Strings.  This `ChoiceBox` in this article is built on a JavaFX class called `Pair`.  `Pair` is a general container for any key/value pair and can be used in place of a domain or other special-purpose object.  Strings should only be used if they can be used without manipulation or decoded consistently.

[source,java]
.ChoicesApp.class
----
public class ChoicesApp extends Application {

    private final ChoiceBox<Pair<String,String>> assetClass = new ChoiceBox<>();

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label label = new Label("Asset Class:");
        assetClass.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                label,
                assetClass,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initChoice();

        saveButton.setOnAction(
                (evt) -> System.out.println("saving " + assetClass.getValue())
        );

        primaryStage.setTitle("ChoicesApp");
        primaryStage.setScene( scene );
        primaryStage.show();

    }
----

=== StringConverter

When using a complex object to back a `ChoiceBox`, a `StringConverter` is needed.  This object serializes a String to and from the `ChoiceBox`.  For this program, only the toString() needs to be coded which replaces the default toString() of the `Pair` object.  (Both toString and fromString will need an implementation in order to compile.)

An empty object EMPTY_PAIR is used to prevent NullPointerExceptions.  The returned value from assetClass().getValue() can be accessed and compared consistently without adding special null handling logic.

[source,java]
----
    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    private void initChoice() {

        List<Pair<String,String>> assetClasses = new ArrayList<>();
        assetClasses.add( new Pair("Equipment", "20000"));
        assetClasses.add( new Pair("Furniture", "21000"));
        assetClasses.add( new Pair("Investment", "22000"));

        assetClass.setConverter( new StringConverter<Pair<String,String>>() {
            @Override
            public String toString(Pair<String, String> pair) {
                return pair.getKey();
            }

            @Override
            public Pair<String, String> fromString(String string) {
                return null;
            }
        });

        assetClass.getItems().add( EMPTY_PAIR );
        assetClass.getItems().addAll( assetClasses );
        assetClass.setValue( EMPTY_PAIR );

    }
----

The ChoiceBox is used to select from a list of values.  When the list of values is a complex type, provide a StringFormatter to serialize a list object into something presentable.  If possible, use an empty object (rather than a null) to support optional values.

==== Complete Code

The code can be tested in a single .java file.

[source,java]
.ChoicesApp.class
----
public class ChoicesApp extends Application {

    private final ChoiceBox<Pair<String,String>> assetClass = new ChoiceBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label label = new Label("Asset Class:");
        assetClass.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                label,
                assetClass,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initChoice();

        saveButton.setOnAction(
                (evt) -> System.out.println("saving " + assetClass.getValue())
        );

        primaryStage.setTitle("ChoicesApp");
        primaryStage.setScene( scene );
        primaryStage.show();

    }

    private void initChoice() {

        List<Pair<String,String>> assetClasses = new ArrayList<>();
        assetClasses.add( new Pair("Equipment", "20000"));
        assetClasses.add( new Pair("Furniture", "21000"));
        assetClasses.add( new Pair("Investment", "22000"));

        assetClass.setConverter( new StringConverter<Pair<String,String>>() {
            @Override
            public String toString(Pair<String, String> pair) {
                return pair.getKey();
            }

            @Override
            public Pair<String, String> fromString(String string) {
                return null;
            }
        });

        assetClass.getItems().add( EMPTY_PAIR );
        assetClass.getItems().addAll( assetClasses );
        assetClass.setValue( EMPTY_PAIR );

    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== ComboBox

A `ComboBox` is a hybrid control that presents a list of values plus an edit control.  This article demonstrates a basic form of the `ComboBox` which is an un-editable list of items built on a complex data structure.

This screenshot shows a ComboBoxApp containing a list of expense accounts.  The accounts are stored in a key/value JavaFX class `Pair`.  The console shows the result of a save operation after the user selects "Auto Expense".

image::images/ui-controls/combobox.png[title="ComboBox Application"]

This code adds a Label, a ComboBox, and a Button to an HBox.  The ComboBox is instantiated as a field and initialized in a method presented later initCombo().  A handler is put on the Save Button which outputs a value if an item is selected or a special message if no item is selected.

[source,java]
.CombosApp.class
----
public class CombosApp extends Application {

    private final ComboBox<Pair<String, String>> account = new ComboBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label accountsLabel = new Label("Account:");
        account.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                accountsLabel,
                account,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initCombo();

        saveButton.setOnAction( (evt) -> {
            if( account.getValue().equals(EMPTY_PAIR) ) {
                System.out.println("no save needed; no item selected");
            } else {
                System.out.println("saving " + account.getValue());
            }
        });

        primaryStage.setTitle("CombosApp");
        primaryStage.setScene( scene );
        primaryStage.show();
    }
----

=== CellFactory

The initCombo() method adds several expense accounts to a `List`.   This `List` is added to the `ComboBox` items after an empty `Pair` object is added.  The initial value is set to the EMPTY_PAIR which is a constant.

If not specified, the `ComboBox` will use the toString() method of the object (in this article, a `Pair`) to render a backing object.  For Strings, such as a "Yes" or "No" selection, no extra code is needed.  However, the toString() of a `Pair` will output both the human-readable key and the machine-preferred value.  The requirements for this `ComboBox` are to use only the human-readable keys in the display.

To do this, a cellFactory is provided which will configure a `ListCell` object with the `Pair` key as the contents.  The `Callback` type is verbose, but the gist of the factory is set the text of a `ListCell` in the updateItem() method of an anonymous inner class.  Notice that the super class method must be called.

[source,java]
----
    private void initCombo() {

        List<Pair<String,String>> accounts = new ArrayList<>();

        accounts.add( new Pair<>("Auto Expense", "60000") );
        accounts.add( new Pair<>("Interest Expense", "61000") );
        accounts.add( new Pair<>("Office Expense", "62000") );
        accounts.add( new Pair<>("Salaries Expense", "63000") );

        account.getItems().add( EMPTY_PAIR );
        account.getItems().addAll( accounts );
        account.setValue( EMPTY_PAIR );

        Callback<ListView<Pair<String,String>>, ListCell<Pair<String,String>>> factory =
            (lv) ->
                    new ListCell<Pair<String,String>>() {
                        @Override
                        protected void updateItem(Pair<String, String> item, boolean empty) {
                            super.updateItem(item, empty);
                            if( empty ) {
                                setText("");
                            } else {
                                setText( item.getKey() );
                            }
                        }
                    };

        account.setCellFactory( factory );
        account.setButtonCell( factory.call( null ) );
    }
----

The `Callback` is used in the setButtonCell() method to provide a cell for the editing control.  Note that this program is not editable which is the default.  However, the factory.call(null) is needed otherwise only the contents of the popup menu will be properly formatted and the view of the control at rest will fallback on a toString().

This article presented a simple usage of `ComboBox`.  Since this control was not editable, `ChoiceBox` can be substituted.  For un-editable graphical renderings (ex a color coded shape for a status value), `ComboBox` still would be needed to define the specific `Node` used in the control.

==== Complete Code

The code can be tested in a single .java file.

[source,java]
.CombosApp.class
----
public class CombosApp extends Application {

    private final ComboBox<Pair<String, String>> account = new ComboBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label accountsLabel = new Label("Account:");
        account.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                accountsLabel,
                account,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initCombo();

        saveButton.setOnAction( (evt) -> {
            if( account.getValue().equals(EMPTY_PAIR ) ) {
                System.out.println("no save needed; no item selected");
            } else {
                System.out.println("saving " + account.getValue());
            }
        });

        primaryStage.setTitle("CombosApp");
        primaryStage.setScene( scene );
        primaryStage.show();
    }

    private void initCombo() {

        List<Pair<String,String>> accounts = new ArrayList<>();

        accounts.add( new Pair<>("Auto Expense", "60000") );
        accounts.add( new Pair<>("Interest Expense", "61000") );
        accounts.add( new Pair<>("Office Expense", "62000") );
        accounts.add( new Pair<>("Salaries Expense", "63000") );

        account.getItems().add( EMPTY_PAIR );
        account.getItems().addAll( accounts );
        account.setValue( EMPTY_PAIR );

        Callback<ListView<Pair<String,String>>, ListCell<Pair<String,String>>> factory =
            (lv) ->
                    new ListCell<Pair<String,String>>() {
                        @Override
                        protected void updateItem(Pair<String, String> item, boolean empty) {
                            super.updateItem(item, empty);
                            if( empty ) {
                                setText("");
                            } else {
                                setText( item.getKey() );
                            }
                        }
                    };

        account.setCellFactory( factory );
        account.setButtonCell( factory.call( null ) );
    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

== ListView

=== ListView Filtering in JavaFX

This article demonstrates how to filter a ListView in a JavaFX Application.  Two lists are managed by the Application.  One list contains all of the items in the data model.  The second list contains the items currently being viewed.  A scrap of comparison logic stored as a filter mediates between the two.

Binding is used heavily to keep the data structures in sync with what the user has selected.

This screenshot shows the Application which contains a top row of ToggleButtons which set the filter and a ListView containing the objects.

image::images/ui-controls/listview_filtering_screenshot.png[title="Screenshot of ListView Filtering App"]

The complete code -- a single .java file -- is listed at the end of the article.

==== Data Structures

The program begins with a domain model Player and an array of Player objects.

[source,java]
----
static class Player {
	
	private final String team;
	private final String playerName;
	public Player(String team, String playerName) {
		this.team = team;
		this.playerName = playerName;
	}
	public String getTeam() {
		return team;
	}
	public String getPlayerName() {
		return playerName;
	}
	@Override
	public String toString() { return playerName + " (" + team + ")"; }
}
----

The Player class contains a pair of fields, team and playerName.  A toString() is provided so that when the object is added to the ListView (presented later), a custom ListCell class is not needed.

The test data for this example is a list of American baseball players.

[source,java]
----
Player[] players = {new Player("BOS", "David Ortiz"),
                    new Player("BOS", "Jackie Bradley Jr."),
                    new Player("BOS", "Xander Bogarts"),
                    new Player("BOS", "Mookie Betts"),
                    new Player("HOU", "Jose Altuve"),
                    new Player("HOU", "Will Harris"),
                    new Player("WSH", "Max Scherzer"),
                    new Player("WSH", "Bryce Harper"),
                    new Player("WSH", "Daniel Murphy"),
                    new Player("WSH", "Wilson Ramos") };
----

==== Model

As mentioned at the start of the article, the ListView filtering is centered around the management of two lists.  All the objects are stored in a wrapped ObservableList playersProperty and the objects that are currently viewable are stored in a wrapped FilteredList, viewablePlayersProperty.  viewablePlayersProperty is built off of playersProperty so updates made to players that meet the FilteredList criteria will also be made to viewablePlayers.

[source,java]
----
ReadOnlyObjectProperty<ObservableList<Player>> playersProperty = 
		new SimpleObjectProperty<>(FXCollections.observableArrayList());

ReadOnlyObjectProperty<FilteredList<Player>> viewablePlayersProperty =
		new SimpleObjectProperty<FilteredList<Player>>(
				new FilteredList<>(playersProperty.get()
						));
----

filterProperty() is a convenience to allow callers to bind to the underlying Predicate.  

[source,java]
----
ObjectProperty<Predicate<? super Player>> filterProperty = 
	viewablePlayersProperty.get().predicateProperty();
----

The UI root is a VBox which contains an HBox of ToggleButtons and a ListView.

[source,java]
----
VBox vbox = new VBox();
vbox.setPadding( new Insets(10));
vbox.setSpacing(4);

HBox hbox = new HBox();
hbox.setSpacing( 2 );

ToggleGroup filterTG = new ToggleGroup();
----

==== Filtering Action

A handler is attached the ToggleButtons which will modify filterProperty.  Each ToggleButton is supplied a Predicate in the userData field.  toggleHandler uses this supplied Predicate when setting the filter property.  This code sets the special case "Show All" ToggleButton.

[source,java]
----
@SuppressWarnings("unchecked")
EventHandler<ActionEvent> toggleHandler = (event) -> {
		ToggleButton tb = (ToggleButton)event.getSource();
	    Predicate<Player> filter = (Predicate<Player>)tb.getUserData();
	    filterProperty.set( filter );
	};

ToggleButton tbShowAll = new ToggleButton("Show All");
tbShowAll.setSelected(true);
tbShowAll.setToggleGroup( filterTG );	
tbShowAll.setOnAction(toggleHandler);
tbShowAll.setUserData( (Predicate<Player>) (Player p) -> true);
----

The ToggleButtons that filter a specific team are created at runtime based on the Players array.  This Stream does the following.

. Distill the list of Players down to a distinct list of team Strings
. Create a ToggleButton for each team String
. Set a Predicate for each ToggleButton to be used as a filter
. Collect the ToggleButtons for addition into the HBox container

[source,java]
----
List<ToggleButton> tbs = Arrays.asList( players)
		.stream()
		.map( (p) -> p.getTeam() )
		.distinct()
		.map( (team) -> {
			ToggleButton tb = new ToggleButton( team );
			tb.setToggleGroup( filterTG );
			tb.setOnAction( toggleHandler );
			tb.setUserData( (Predicate<Player>) (Player p) -> team.equals(p.getTeam()) );
			return tb;
		})
		.collect(Collectors.toList());

hbox.getChildren().add( tbShowAll );
hbox.getChildren().addAll( tbs );
----

==== ListView 

The next step creates the ListView and binds the ListView to the viewablePlayersProperty.  This enables the ListView to receive updates based on the changing filter.

[source,java]
----
ListView<Player> lv = new ListView<>();
lv.itemsProperty().bind( viewablePlayersProperty );
----

The remainder of the program creates a Scene and shows the Stage.  onShown loads the data set into the playersProperty and the viewablePlayersProperty lists.  Although both lists are in sync in this partcular version of the program, if the stock filter is every different than "no filter", this code would not need to be modified.

[source,java]
----
vbox.getChildren().addAll( hbox, lv );

Scene scene = new Scene(vbox);

primaryStage.setScene( scene );
		primaryStage.setOnShown((evt) -> {
			playersProperty.get().addAll( players );
		});

primaryStage.show();
----

This article used binding to tie a list of viewable Player objects to a ListView.  The viewable Players were updated when a ToggleButton is selected.  The selection applied a filter to a full set of Players which was maintained separately as a FilteredList (thanks @kleopatra_jx).  Binding was used to keep the UI in sync and to allow for a separation of concerns in the design.

==== Further Reading

To see how such a design would implement basic add and remove functionality, visit the following page https://courses.bekwam.net/public_tutorials/bkcourse_filterlistapp.php.

==== Complete Code

The code can be tested in a single .java file.

[source,java]
----
public class FilterListApp extends Application {

	@Override
	public void start(Stage primaryStage) throws Exception {
		
		//
		// Test data
		//
		Player[] players = {new Player("BOS", "David Ortiz"),
		                    new Player("BOS", "Jackie Bradley Jr."),
		                    new Player("BOS", "Xander Bogarts"),
		                    new Player("BOS", "Mookie Betts"),
		                    new Player("HOU", "Jose Altuve"),
		                    new Player("HOU", "Will Harris"),
		                    new Player("WSH", "Max Scherzer"),
		                    new Player("WSH", "Bryce Harper"),
		                    new Player("WSH", "Daniel Murphy"),
		                    new Player("WSH", "Wilson Ramos") };
		
		//
		// Set up the model which is two lists of Players and a filter criteria
		//
		ReadOnlyObjectProperty<ObservableList<Player>> playersProperty = 
				new SimpleObjectProperty<>(FXCollections.observableArrayList());
		
		ReadOnlyObjectProperty<FilteredList<Player>> viewablePlayersProperty =
				new SimpleObjectProperty<FilteredList<Player>>(
						new FilteredList<>(playersProperty.get()
								));
		
		ObjectProperty<Predicate<? super Player>> filterProperty = 
			viewablePlayersProperty.get().predicateProperty();
		

		//
		// Build the UI
		//
		VBox vbox = new VBox();
		vbox.setPadding( new Insets(10));
		vbox.setSpacing(4);
		
		HBox hbox = new HBox();
		hbox.setSpacing( 2 );
		
		ToggleGroup filterTG = new ToggleGroup();
		
		//
		// The toggleHandler action wills set the filter based on the TB selected
		//
		@SuppressWarnings("unchecked")
		EventHandler<ActionEvent> toggleHandler = (event) -> {
				ToggleButton tb = (ToggleButton)event.getSource();
			    Predicate<Player> filter = (Predicate<Player>)tb.getUserData();
			    filterProperty.set( filter );
			};
		
		ToggleButton tbShowAll = new ToggleButton("Show All");
		tbShowAll.setSelected(true);
		tbShowAll.setToggleGroup( filterTG );	
		tbShowAll.setOnAction(toggleHandler);
		tbShowAll.setUserData( (Predicate<Player>) (Player p) -> true);
		
		//
		// Create a distinct list of teams from the Player objects, then create
		// ToggleButtons
		//
		List<ToggleButton> tbs = Arrays.asList( players)
				.stream()
				.map( (p) -> p.getTeam() )
				.distinct()
				.map( (team) -> {
					ToggleButton tb = new ToggleButton( team );
					tb.setToggleGroup( filterTG );
					tb.setOnAction( toggleHandler );
					tb.setUserData( (Predicate<Player>) (Player p) -> team.equals(p.getTeam()) );
					return tb;
				})
				.collect(Collectors.toList());
		
		hbox.getChildren().add( tbShowAll );
		hbox.getChildren().addAll( tbs );
		
		//
		// Create a ListView bound to the viewablePlayers property
		//
		ListView<Player> lv = new ListView<>();
		lv.itemsProperty().bind( viewablePlayersProperty );
		
		vbox.getChildren().addAll( hbox, lv );
		
		Scene scene = new Scene(vbox);
		
		primaryStage.setScene( scene );
		primaryStage.setOnShown((evt) -> {
			playersProperty.get().addAll( players );
		});
		
		primaryStage.show();
		
	}

	public static void main(String args[]) {
		launch(args);
	}
	
	static class Player {
		
		private final String team;
		private final String playerName;
		public Player(String team, String playerName) {
			this.team = team;
			this.playerName = playerName;
		}
		public String getTeam() {
			return team;
		}
		public String getPlayerName() {
			return playerName;
		}
		@Override
		public String toString() { return playerName + " (" + team + ")"; }
	}
}
----

== TableView

For JavaFX business applications, the `TableView` is an essential control.  Use a `TableView` when you need to present multiple records in a flat row/column structure.  This example shows the basic elements of a `TableView` and demonstrates the power of the component when JavaFX Binding is applied.

The demonstration app is a `TableView` and a pair of Buttons.  The `TableView` has four TableColumns: SKU, Item, Price, Tax.  The `TableView` shows three objects in three rows: Mechanical Keyboard, Product Docs, O-Rings.  The following screenshot shows the app immediately after startup.

image::images/ui-controls/tableviewselectapp_screenshot.png[title="Intial View of Demo App"]

The disabled logic of the Buttons is based on the selections in the `TableView`.  Initially, no items are selected so both Buttons are disabled.  If any item is selected -- the first item in the following screenshot -- the Inventory `Button` is enabled.  The Tax `Button` is also enabled although that requires consulting the Tax value.

image::images/ui-controls/tableviewselectapp_screenshot_selected_tax.png[title="With Taxable Item Selected"]

If the Tax value for the selected item is false, then the Tax `Button` will be disabled.  This screenshot shows the second item selected.  The Inventory `Button` is enabled but the Tax `Button` is not.

image::images/ui-controls/tableviewselectapp_screenshot_selected_notax.png[title="A Non-Taxable Item Disables the Tax Button"]

=== Model and Declarations

A `TableView` is based on a model which is a POJO called Item.

[source,java]
.Item.java
----
public class Item {

    private final String sku;
    private final String descr;
    private final Float price;
    private final Boolean taxable;

    public Item(String sku, String descr, Float price, Boolean taxable) {
        this.sku = sku;
        this.descr = descr;
        this.price = price;
        this.taxable = taxable;
    }

    public String getSku() {
        return sku;
    }

    public String getDescr() {
        return descr;
    }

    public Float getPrice() {
        return price;
    }

    public Boolean getTaxable() {
        return taxable;
    }
}
----

The `TableView` and `TableColumn` use generics in their declarations.  For `TableView`, the type parameter is Item.  For the TableColumns, the type parameters are Item and the field type.  The constructor of `TableColumn` accepts a column name.  In this example, the column names diverge slightly from the actual field names.

[source,java]
.TableSelectApp.java
----
        TableView<Item> tblItems = new TableView<>();

        TableColumn<Item, String> colSKU = new TableColumn<>("SKU");
        TableColumn<Item, String> colDescr = new TableColumn<>("Item");
        TableColumn<Item, Float> colPrice = new TableColumn<>("Price");
        TableColumn<Item, Boolean> colTaxable = new TableColumn<>("Tax");

        tblItems.getColumns().addAll(
            colSKU, colDescr, colPrice, colTaxable
        );
----

Adding model items to the `TableView` is done by adding items to the underlying collection.

[source,java]
.TableSelectApp.java
----
        tblItems.getItems().addAll(
            new Item("KBD-0455892", "Mechanical Keyboard", 100.0f, true),
            new Item( "145256", "Product Docs", 0.0f, false ),
            new Item( "OR-198975", "O-Ring (100)", 10.0f, true)
        );
----

At this point, the `TableView` has been configured and test data has been added.  However, if you were to view the program, you would see three empty rows.  That is because JavaFX is missing the linkage between the POJO and the TableColumns.  That linkage is added to the TableColumns using a cellValueFactory.

[source,java]
.TableSelectApp.java
----
        colSKU.setCellValueFactory( new PropertyValueFactory<>("sku") );
        colDescr.setCellValueFactory( new PropertyValueFactory<>("descr") );
        colPrice.setCellValueFactory( new PropertyValueFactory<>("price") );
        colTaxable.setCellValueFactory( new PropertyValueFactory<>("taxable") );
----

Viewing the program at this point will display the data in the appropriate columns.

=== Selection

To retrieve the selected item or items in a `TableView`, use the separate selectionModel object.  Calling tblItems.getSelectionModel() returns an object that includes a property "selectedItem".  This can be retrieved and used in a method, say to bring up an edit details screen.  Alternatively, getSelectionModel() can return a JavaFX property "selectedItemProperty" for binding expressions.

In the demo app, two Buttons are bound to the selectionModel of the `TableView`.  Without binding, you might add listeners that examine the selection and make a call like setDisabled() on a Button.  Prior to the `TableView` selection, you would also need initialization logic to handle the case where there is no selection.  The binding syntax expresses this logic in a declarative statement that can handle both the listener and the initialization in a single line.

[source,java]
.TableSelectApp.java
----
        Button btnInventory = new Button("Inventory");
        Button btnCalcTax = new Button("Tax");

        btnInventory.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull() <1>
        );
----

<1> See "Ignoring Warnings for Null Select Binding Expressions" under "Best Practices" to show how to turn off warning messages when using this construct

The btnInventory disable property will be true if there is no item selected (isNull()).  When the screen is first displayed, no selection is made and the `Button` is disabled.  Once any selection is made, btnInventory is enabled (disable=false).

the btnCalcTax logic is slightly more complex.  btnCalcTax too is disabled when there is no selection.  However, btnCalcTax will also consider the contents of the selectedItem.  A composite binding or() is used to join these two conditions.  As before, there is an isNull() expression for no selection.  The Bindings.select() checks the value of Item.taxable.  A true taxable Item will enable btnCalcTax while a false item will disable the `Button`.

[source,java]
.TableSelectApp.java
----
        btnCalcTax.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull().or(
                    Bindings.select(
                        tblItems.getSelectionModel().selectedItemProperty(),
                        "taxable"
                    ).isEqualTo(false)
            )
        );
----

Bindings.select() is the mechanism to extract a field from an object.  selectedItemProperty() is the changing selectedItem and "taxable" is the single-hop path to the taxable field.

This example showed how to set up a `TableView` based on a POJO.  It also featured a pair of powerful binding expressions that allow you to link related controls without writing extra listeners and initialization code.  The `TableView` is an indispensable control for the JavaFX business applications developer.  It will be the best and most familiar control for displaying a list of structured items.

=== Complete Code

The complete code for the application follows.  It is a pair of class files TableSelectApp.java and Item.java.  Item.java was already presented in its entirety in an earlier section.

[source,java]
.TableSelectApp.java
----
public class TableSelectApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        TableView<Item> tblItems = new TableView<>();
        tblItems.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        VBox.setVgrow(tblItems, Priority.ALWAYS );

        TableColumn<Item, String> colSKU = new TableColumn<>("SKU");
        TableColumn<Item, String> colDescr = new TableColumn<>("Item");
        TableColumn<Item, Float> colPrice = new TableColumn<>("Price");
        TableColumn<Item, Boolean> colTaxable = new TableColumn<>("Tax");

        colSKU.setCellValueFactory( new PropertyValueFactory<>("sku") );
        colDescr.setCellValueFactory( new PropertyValueFactory<>("descr") );
        colPrice.setCellValueFactory( new PropertyValueFactory<>("price") );
        colTaxable.setCellValueFactory( new PropertyValueFactory<>("taxable") );

        tblItems.getColumns().addAll(
            colSKU, colDescr, colPrice, colTaxable
        );

        tblItems.getItems().addAll(
            new Item("KBD-0455892", "Mechanical Keyboard", 100.0f, true),
            new Item( "145256", "Product Docs", 0.0f, false ),
            new Item( "OR-198975", "O-Ring (100)", 10.0f, true)
        );

        Button btnInventory = new Button("Inventory");
        Button btnCalcTax = new Button("Tax");

        btnInventory.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull()
        );

        btnCalcTax.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull().or(
                    Bindings.select(
                        tblItems.getSelectionModel().selectedItemProperty(),
                        "taxable"
                    ).isEqualTo(false)
            )
        );

        HBox buttonHBox = new HBox( btnInventory, btnCalcTax );
        buttonHBox.setSpacing( 8 );

        VBox vbox = new VBox( tblItems, buttonHBox );
        vbox.setPadding( new Insets(10) );
        vbox.setSpacing( 10 );

        Scene scene = new Scene(vbox);

        primaryStage.setTitle("TableSelectApp");
        primaryStage.setScene( scene );
        primaryStage.setHeight( 376 );
        primaryStage.setWidth( 667 );
        primaryStage.show();
    }

    public static void main(String[] args) {

        launch(args);
    }
}
----

== ImageView

JavaFX provides the `Image` and `ImageView` classes to display BMP, GIF, JPEG, and PNG graphical images.  Image is a class that holds the bytes of the image and optionally scaling information.  The Image object is loaded by a background thread, and the Image class provides methods for interacting with the load operation.  The Image object is used independently of ImageView to create cursors and app icons.

ImageView is a JavaFX `Node` that holds an Image object.  ImageView makes an image available throughout the framework.  An ImageView can be added to a container by itself or alongside other UI controls.  For example an image can be added to a `Label` by setting the graphic property of the Label.

******************************************************************
Images can also be displayed and manipulated using JavaFX CSS.
******************************************************************

This screenshot shows a `TilePane` containing four equally-sized tiles.  Each tile contains an ImageView of a keyboard.

image::images/ui-controls/imageapp_screenshot.png[title="Different Image and ImageView Settings"]

The top-left image is displayed using the original image size of 320x240.  The top-right image is scaled proportionally.  Since the top-right image is a rectangle and the containing tile is a square, there are gaps on the top and bottom to maintain the correct ratio when stretching the width.

The lower-left image fills the container completely. However, in making the rectangular image fit the square container, the image is not scaled proportionally and instead strethed in both directions.

The lower-right image fills the container using a zoomed-in version of the image.  A square Viewport is created from a 100x100 Rectangle2D and scaled up proportionally. While the low-quality image is blurry, it is not deformed. 

=== Image

The Image class provides constructors to build an Image object from the image file dimensions or from a transformed object.  These three constructor calls create the Image objects used in the top-right, bottom-left and bottom-right tiles, respectively.

[source,java]
.ImageApp.java
----
public class ImageApp extends Application {

    private final static String IMAGE_LOC = "images/keyboard.jpg";

    @Override
    public void start(Stage primaryStage) throws Exception {

        Image image2 = new Image(IMAGE_LOC, 360.0d, 360.0d, true, true );
        Image image3 = new Image(IMAGE_LOC, 360.0d, 360.0d, false, true);
        Image image4 = new Image(IMAGE_LOC);
----

The String URL passed in to all forms of the Image constructor is relative to the classpath.  An absolute URL such as "https://www.bekwam.com/images/bekwam_logo_hdr_rounded.png" can also be used.  Note that the absolute URLs will not throw an error if their resource is not found.

image2 and image3 specify dimensions, forming a square larger than the rectangle of the original image.  image2 will preserve the aspect ratio ("true").  The constructor of image3 does not preserve the aspect ratio and will appear stretched.

=== ImageView

ImageView is a Node container that allows the Image object to be used in JavaFX containers and UI controls.  In the top-left image, a short form of ImageView is used which passes in only the image URL.  It will honor the original dimensions and does not require an additional Image object.

[source,java]
.ImageApp.java
----
        ImageView iv1 = new ImageView(IMAGE_LOC);

        ImageView iv2 = new ImageView(image2);
        ImageView iv3 = new ImageView(image3);
        ImageView iv4 = new ImageView(image4);

        iv4.setPreserveRatio(true);
        iv4.setFitHeight(360);
        iv4.setFitWidth(360);
        Rectangle2D viewportRect = new Rectangle2D(20, 50, 100, 100);
        iv4.setViewport(viewportRect);
----

iv2 and iv3 are based on the image2 and image3 objects.  Recall that these objects produced transformed images that fit the square container.

iv4 is also based on a transformed Image object, but in the case of iv4, the transformation is done through the ImageView object rather than the Image.  ImageView.setFitHeight is called rather than Image.setFitHeight.

Additionally, the Viewport of iv4 is adjusted.  The Viewport controls the visible part of the ImageView.  In this case, the Viewport is defined as a 100x100 section of the Image shifted left 20 pixels and up 50 pixels. 

This section demonstrated the Image and ImageView classes which are used to display an image in a container or other UI control.  These classes define the scaling behavior of the image and can be used with a Rectangle2D Viewport to give additional image display customization.

=== Source

The complete source code and Gradle project can be found at the link below.

https://courses.bekwam.net/public_tutorials/source/bkcourse_imageapp_sources.zip[ImageApp Source Zip]

== LineChart

While you can plot a graph using a `Line` on a `Canvas`, JavaFX's `LineChart` makes graphing easier.  In addition to customizing standard charting components like axis legends, LineChart encapsulates the source data of the graph.  As with all JavaFX controls, LineChart enables you to style the graph using CSS.

This screenshot shows a plot of seven points.  The X-Axis has units of Time Constants ranging from 0 to 5.  The Y-Axis shows Voltage ranging from 0 to 1 with more frequent gradients than the X-Axis.

image::images/ui-controls/linechartapp_screenshot.png[title="LineChartApp Screenshot"]

=== Data

LineChart includes an API for managing data.  Data points are grouped into series.  This particular example uses a single series.

[source,java]
.LineChartApp.java
----
public class LineChartApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        XYChart.Series<Double, Double> series = new XYChart.Series<>();
        series.getData().add( new XYChart.Data<>(0.0,0.0));
        series.getData().add( new XYChart.Data<>(0.7,0.5));
        series.getData().add( new XYChart.Data<>(1.0,0.632));
        series.getData().add( new XYChart.Data<>(2.0,0.865));
        series.getData().add( new XYChart.Data<>(3.0,0.95));
        series.getData().add( new XYChart.Data<>( 4.0, 0.982 ));
        series.getData().add( new XYChart.Data<>( 5.0, 0.993 ));
----

Each data point is an `XYChart.Data` object that is added to an `XYChart.Series` container.  To show a comparison of different series, create additional XYChart.Series objects.  These will be rendered as different colors by the LineChart.

=== Chart

The LineChart object is created with Axis objects.  The first Axis parameter is for the X axis. Each Axis object includes an optional label: Time Constant, Voltage (Vs).  The next two numeric parameters give the lower and upper bounds.  The final parameter sets the step increment.  Another form of the LineChart constructor, not used in this example, accepts the data.  This example, makes an explicit add() call on the LineChart's data field.

[source,java]
.LineChartApp.java
----
        LineChart lc = new LineChart(
                new NumberAxis("Time Constant", 0.0, 5.0, 1),
                new NumberAxis("Voltage (Vs)", 0.0, 1.0, 0.1)
                );

        lc.getData().add( series );    
----

The LineChart can be customized with a title using setTitle() and an individual style with setStyle().  For consistency, it is best to use a style sheet so that a single style definition can be applied across a set of LineCharts.

[source,java]
.LineChartApp.java
----
        lc.setTitle("RC Charging");
        lc.setStyle("-fx-background-color: lightgray");
----

There are many other properties that can be set to configure the LineChart.  setLegendVisible() removes a series identifier since there is only one series in this graph.  setCreateSymbols() removes a graphic on each data point that was being clipped at the origin and end of the graph.

[source,java]
.LineChartApp.java
----
        lc.setCreateSymbols(false);
        lc.setLegendVisible(false);
----

For modest reporting requirements, JavaFX provides classes like LineChart to plot multiple series of data points into a graph.  The LineChart object is highly customizable, giving control over the legends, lines, and data point icons.  Additionally, CSS styling is available to make a set of these reports consistent.

=== Source

The complete source code and Gradle project can be found at the link below.

https://courses.bekwam.net/public_tutorials/source/bkcourse_chartapp_sources.zip[ChartApp Source Zip]

== Pagination

Pagination is a UI control that lets you step through blocks of results using next, previous, and direct indexing buttons.  The Pagination class can break up long lists when scrolling is not desired.  This section presents a special case of single-item pages to form a slideshow.

=== SlideShow App

This screenshot shows the app which is a slideshow of three images.  The Pagination control renders the custom Node -- an ImageView -- and buttons at the bottom of the screen.  For each of the three images, there is a direct access button 1, 2, and 3.  There is also a pair of arrows to move to the next and previous image.  A Label marks the image index and number of images to supplement the visual cues of the buttons themselves.

image::images/ui-controls/pagination_screenshot.png[title="Pagination on First of Three Pages"]

The program begins by defining a array of three JavaFX Images: imageURLs.  In the start() method, a Pagination object is created that references the size of the array.  A PageFactory is provided which creates a Node based on the pageIndex parameter.  For this example, the pageIndex is an index into the imageURLs array.

The program forms a Scene and adds it to the primaryStage.

[source,java]
.SlideShowApp.java
----
public class SlideShowApp extends Application {

    private Image[] imageURLs = {
            new Image("https://www.bekwam.net/images/bekwam_rc_charging.png"),
            new Image("https://www.bekwam.net/images/bekwam_rc_discharging.png"),
            new Image("https://www.bekwam.net/images/bekwam_rl_scope.png")
    };

    @Override
    public void start(Stage primaryStage) throws Exception {

        Pagination pagination = new Pagination(imageURLs.length, 0);
        pagination.setPageFactory(
            pageIndex -> new ImageView(imageURLs[pageIndex])
        );

        VBox vbox = new VBox( pagination );

        Scene scene = new Scene(vbox);

        primaryStage.setScene( scene );
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
----

The Pagination class is a simple control to iterate through a long list of items.  This example used a single item per page to form a slideshow.  In both cases, this is an alternative to scrolling and is useful when you want the UI to be fixed in position.
